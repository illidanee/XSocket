#include "XReceiveServer.h"

XReceiveServer::XReceiveServer(int id)
	:
	_ID(id),
	_pEventObj(nullptr),
	_LastTime(0),
	_ClientChange(true),
	_MaxSocketID(0),
	_Run(false)
{
}

XReceiveServer::~XReceiveServer()
{
}

int XReceiveServer::Init(XIEvent* pEventObj)
{
	//设置对象
	_pEventObj = pEventObj;
	//设置时间
	_LastTime = XTimer::GetTimeByMicroseconds();

	return 0;
}

int XReceiveServer::Done()
{
	_pEventObj = nullptr;
	_LastTime = 0;

	return 0;
}

int XReceiveServer::Start()
{
	XLog("XReceiveServer<ID=%d>:Start() Begin\n", _ID);

	_TaskServer.Start(_ID);

	_Run = true;
	std::thread t(std::mem_fn(&XReceiveServer::OnRun), this);
	t.detach();

	XLog("XReceiveServer<ID=%d>:Start() End\n", _ID);
	return 0;
}

int XReceiveServer::Stop()
{
	XLog("XReceiveServer<ID=%d>:Stop() Begin\n", _ID);

	//关闭服务线程
	_Signal.Sleep();
	_Run = false;
	_Signal.Wait();

	//关闭任务服务线程
	_TaskServer.Stop(_ID);

	//关闭所有客户端连接
	_AllClients.clear();
	_AllClientsCache.clear();

	XLog("XReceiveServer<ID=%d>:Stop() End\n", _ID);
	return 0;
}

void XReceiveServer::AddClient(const std::shared_ptr<XClient> pClient)
{
	std::lock_guard<std::mutex> lock(_AllClientsCacheMutex);
	_AllClientsCache.insert(std::pair<SOCKET, std::shared_ptr<XClient>>(pClient->GetSocket(), pClient));
}

int XReceiveServer::GetClientNum()
{
	return (int)_AllClients.size() + (int)_AllClientsCache.size();
}

void XReceiveServer::AddTask(std::function<void()> pTask)
{
	_TaskServer.AddTask(pTask);
}

int XReceiveServer::OnRun()
{
	XLog("XReceiveServer<ID=%d>:OnRun() Begin\n", _ID);
	while (_Run)
	{
		//循环计时。
		time_t curTime = XTimer::GetTimeByMicroseconds();
		time_t delta = curTime - _LastTime;
		_LastTime = curTime;

		//计时检测。
		for (std::map<SOCKET, std::shared_ptr<XClient>>::iterator iter = _AllClients.begin(); iter != _AllClients.end(); )
		{
			//心跳检测！
			if (iter->second->CheckHeartTime(delta))
			{
				if (_pEventObj)
					_pEventObj->OnClientLeave(iter->second);

				iter = _AllClients.erase(iter);
				_ClientChange = true;
				continue;
			}

			//计时发送检测！
			iter->second->CheckSendTime(delta);

			++iter;
		}

		//是否有新客户端加入？
		if (!_AllClientsCache.empty())
		{
			std::lock_guard<std::mutex> lock(_AllClientsCacheMutex);
			for (std::map<SOCKET, std::shared_ptr<XClient>>::iterator iter = _AllClientsCache.begin(); iter != _AllClientsCache.end(); ++iter)
			{
				_AllClients.insert(std::pair<SOCKET, std::shared_ptr<XClient>>(iter->first, iter->second));
				if (_pEventObj)
					_pEventObj->OnClientJoin(iter->second);
			}
			_AllClientsCache.clear();

			_ClientChange = true;
		}

		//是否有客户端连接？
		if (_AllClients.empty())
		{
			//减少CPU消耗。
			std::this_thread::sleep_for(std::chrono::microseconds(1));

			continue;
		}

		//检查是否有客户端向服务器发送数据。
		fd_set fdRead;
		FD_ZERO(&fdRead);

		if (_ClientChange)
		{
			_ClientChange = false;

			_MaxSocketID = 0;
			for (std::map<SOCKET, std::shared_ptr<XClient>>::iterator iter = _AllClients.begin(); iter != _AllClients.end(); ++iter)
			{
				FD_SET(iter->first, &fdRead);
				if (_MaxSocketID < iter->first)
					_MaxSocketID = iter->first;
			}

			memcpy(&_fdSetCache, &fdRead, sizeof(fd_set));
		}
		else
		{
			memcpy(&fdRead, &_fdSetCache, sizeof(fd_set));
		}

		//设置10毫秒间隔，可以提高客户端连接select效率。
		timeval tv = { 0, 1000 };			//使用时间间隔可以提高客户端连接速度。使用阻塞模式更快。但此处不能使用组塞模式，需要执行定时检测任务。
		int ret = select((int)_MaxSocketID + 1, &fdRead, NULL, NULL, &tv);
		if (SOCKET_ERROR == ret)
		{
			XLog("Error:Select!\n");
			return -1;
		}
		else if (0 == ret)
		{
			continue;
		}

		//接收客户端数据
		for (std::map<SOCKET, std::shared_ptr<XClient>>::iterator iter = _AllClients.begin(); iter != _AllClients.end();)
		{
			if (FD_ISSET(iter->first, &fdRead))
			{
				int ret = iter->second->RecvData();
				if (ret < 0)
				{
					if (_pEventObj)
						_pEventObj->OnClientLeave(iter->second);

					iter = _AllClients.erase(iter);
					_ClientChange = true;
					continue;
				}
			}

			++iter;
		}

	}

	XLog("XReceiveServer<ID=%d>:OnRun() End\n", _ID);
	_Signal.Wake();
	return 0;
}
